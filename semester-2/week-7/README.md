# Седьмая неделя. Графы. Мосты. Точки сочленения.
## Задачи

<details><summary> 
<strong>A. Еще раз Дейкстра</strong>
</summary>

### A. Еще раз Дейкстра

Ограничение времени: 1 секунда  
Ограничение памяти: 128Mb

Дан ориентированный граф, рёбрам которого приписаны некоторые неотрицательные веса (длины). Найти длину кратчайшего пути из вершины \( s \) в вершину \( t \).

**Формат ввода**  
В первой строке заданы три числа: число вершин в графе \( N \) (\( N \leq 2 \cdot 10^5 \)), номера вершин \( s \) и \( t \). Далее идёт матрица смежности графа, то есть \( N \) строк, в каждой из которых записано \( N \) чисел. \( j \)-е число в \( i \)-й строке матрицы смежности задает длину ребра, ведущего из \( i \)-й вершины в \( j \)-ю. Длины могут принимать любые значения от 0 до \( 10^5 \), число -1 означает отсутствие соответствующего ребра. Гарантируется, что на главной диагонали матрицы стоят нули.

**Формат вывода**  
Выведите одно число — минимальную длину пути. Если пути не существует, выведите -1.

**Пример**

Ввод:
```
3 1 2
0 -1 3
7 0 1
2 -1 0
```

Вывод:
```
-1
```

###### *Решение: [\*тык\*](a.cpp)*

</details>

<details><summary> 
<strong>B. Флойд-Уоршелл</strong>
</summary>

### B. Флойд-Уоршелл

Ограничение времени: 0.2 секунды  
Ограничение памяти: 16Mb

Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами. Гарантируется, что в графе нет циклов отрицательного веса.

**Формат ввода**  
В первой строке вводится единственное число \( N \) (1 ≤ \( N \) ≤ 100) — количество вершин графа. В следующих \( N \) строках по \( N \) чисел задается матрица смежности графа (j-е число в i-й строке соответствует весу ребра из вершины i в вершину j). Все числа по модулю не превышают 100. На главной диагонали матрицы всегда нули.

**Формат вывода**  
Выведите \( N \) строк по \( N \) чисел — матрицу кратчайших расстояний между парами вершин. j-е число в i-й строке должно быть равно весу кратчайшего пути из вершины i в вершину j.

**Пример**

Ввод:
```
4
0 5 9 100
100 0 2 8
100 100 0 7
4 100 100 0
```

Вывод:
```
0 5 7 13 
12 0 2 8 
11 16 0 7 
4 9 11 0 
```

###### *Решение: [\*тык\*](b.cpp)*

</details>

<details><summary> 
<strong>C. Предатель отрицательного веса</strong>
</summary>

### C. Предатель отрицательного веса

Ограничение времени: 0.2 секунды  
Ограничение памяти: 16Mb

Вы член команды на космическом корабле в игре Among Us. Однако, один из ваших товарищей — скрытый враг, который пытается помешать вам выполнить миссию. Ваша задача — найти кратчайшие пути от вашей текущей позиции на вершине 1 до каждой другой вершины в графе.

Граф содержит отрицательно взвешенные ребра, но при этом не имеет отрицательных циклов. Это означает, что вам не нужно беспокоиться о бесконечном цикле отрицательного веса, который мог бы затянуть вашу команду в бесконечный круг. Однако, вы все еще должны быть осторожны и находиться начеку, чтобы избежать других ловушек, которые может подготовить скрытый враг, чтобы остановить вас.

Сможете ли вы обнаружить скрытого врага и найти кратчайший путь к каждой вершине, чтобы выполнить миссию команды и спасти корабль?

**Формат ввода**  
Число вершин равно \( N \) (1 ≤ \( N \) ≤ 100), а число ребер равно \( M \) (0 ≤ \( M \) ≤ 10000). В следующих строках идет \( M \) троек чисел, описывающих ребра: начало, конец и вес (целое число от -100 до 100).

**Формат вывода**  
Программа должна вывести \( N \) чисел — веса кратчайших путей от вершины 1 до всех остальных. Если нельзя прийти от первой вершины до некоторой, то вместо усилия выведите число 30000.

**Пример**

Ввод:
```
6 4
1 2 10
2 3 10
1 3 100
4 5 -10
```

Вывод:
```
0 10 20 30000 30000 30000 
```

###### *Решение: [\*тык\*](c.cpp)*

</details>

<details><summary> 
<strong>D. Точки сочленения</strong>
</summary>

### D. Точки сочленения

Ограничение времени: 1 секунда  
Ограничение памяти: 64Mb

Найдите точки сочленения в неориентированном графе.

**Формат ввода**  
Первая строка входного файла содержит два натуральных числа \( n \) и \( m \) — количества вершин и рёбер графа соответственно (1 ≤ \( n \) ≤ 20000, 1 ≤ \( m \) ≤ 200000).

Ребро номер \( i \) описывается двумя натуральными числами \( b_i \), \( e_i \) — номерами концов ребра (1 ≤ \( b_i \), \( e_i \) ≤ \( n \)).

**Формат вывода**  
Первая строка выходного файла должна содержать одно натуральное число \( b \) — количество точек сочленения в заданном графе. На следующих \( b \) строках выведите \( b \) целых чисел — номера вершин, которые являются точками сочленения, в возрастающем порядке.

**Пример**

Ввод:
```
9 12
1 2
2 3
4 5
2 6
2 7
8 9
1 3
1 4
1 5
6 7
3 8
3 9
```

Вывод:
```
3
1
2
3
```

###### *Решение: [\*тык\*](d.cpp)*

</details>

<details><summary> 
<strong>E. Мосты</strong>
</summary>

### E. Мосты

Ограничение времени: 2 секунды  
Ограничение памяти: 256.0 Мб

Дан неориентированный (быть может несвязный) граф. Требуется найти все мосты в нем.

**Формат ввода**  
В первой строке входного файла два натуральных числа \( n \) и \( m \) (1 ≤ \( n \) ≤ 20000, 1 ≤ \( m \) ≤ 200000) — количество вершин и рёбер в графе соответственно. Далее в \( m \) строках перечислены рёбра графа. Каждое ребро задается парой чисел — номерами начальной и конечной вершин соответственно.

**Формат вывода**  
Первая строка выходного файла должна содержать одно натуральное число \( b \) — количество мостов в заданном графе. На следующей строке выведите \( b \) чисел — номера ребер, которые являются мостами, в возрастающем порядке. Ребра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

**Пример**

Ввод:
```
6 7
1 2
2 3
3 4
1 3
4 5
4 6
5 6
```

Вывод:
```
1
3
```

**Примечания**  
В графе могут быть как петли, так и кратные ребра.

###### *Решение: [\*тык\*](e.cpp) (не доделано)*

</details>

###### *Конспект лекции: [\*тык\*](aads-lecture-7.pdf)*
###### *Запись лекции: [\*тык\*](https://youtu.be/ZevNNELFMpg)*
# Десятая неделя. Максимальный поток. Форд-Фалкерсон. Эдмонс-Карп.

## Задачи

<details><summary> 
<strong>A. Улиточки</strong>
</summary>

### A. Улиточки

**Ограничение времени**: 2 секунды  
**Ограничение памяти**: 1Gb  
**Ввод**: стандартный ввод или input.txt  
**Вывод**: стандартный вывод или output.txt

Две улиточки Маша и Петя сейчас находятся на лужайке с абрикосами и хотят добраться до своего домика. Лужайки пронумерованы числами от 1 до \(n\) и соединены дорожками (может быть несколько дорожек, соединяющих две лужайки, могут быть дорожки, соединяющие лужайку с собой же). По соображениям гигиены, если по дорожке проползла улиточка, то вторая по той же дорожке уже ползти не может. Помогите Пете и Маше добраться до домика.

### Формат ввода
В первой строке файла записаны четыре целых числа — \(n\), \(m\), \(s\) и \(t\) (количество лужаек, количество дорог, номер лужайки с абрикосами и номер домика). В следующих \(m\) строках записаны пары чисел. Пара чисел \((x, y)\) означает, что есть дорожка с лужайки \(x\) до лужайки \(y\) (из-за особенностей улиток и местности дорожки односторонние). Ограничения: \(2 \leq n \leq 10^5\), \(0 \leq m \leq 10^5\), \(s \ne t\).

### Формат вывода
Если существует решение, то выведите YES и на двух отдельных строчках сначала последовательность лужаек для Машеньки (дам нужно пропускать вперед), затем путь для Пети. Если решения не существует, выведите NO. Если решений несколько, выведите любое.

### Пример

**Ввод**:
```
3 3 1 3
1 2
1 3
2 3
```

**Вывод**:
```
YES
1 3 
1 2 3 
```

### Примечания
Дан орграф, найти два непересекающихся по ребрам пути из \(s\) в \(t\), вывести вершины найденных путей.

###### *Решение: [\*тык\*](a.cpp) (не доделано)*

</details>

<details><summary> 
<strong>B. Поток в двудольном графе</strong>
</summary>

### B. Поток в двудольном графе

**Ограничение времени**: 1 секунда  
**Ограничение памяти**: 256Mb  
**Ввод**: стандартный ввод или input.txt  
**Вывод**: стандартный вывод или output.txt

Дан двудольный граф, исток и сток. Каждая доля состоит из \(N\) вершин. Из истока в \(i\)-ю вершину левой доли ведёт ребро пропускной способности \(a_i\). Из \(i\)-й вершины правой доли ведёт ребро в сток пропускной способности \(b_i\). Также между некоторыми вершинами левой и правой доли есть двунаправленные ребра бесконечной пропускной способности. Вам требуется найти величину максимального потока из истока в сток.

### Формат ввода
В первой строке заданы два числа \(N\) и \(M\) (\(1 \leq N \leq 10^4\), \(0 \leq M \leq 10^5\)) — число вершин в каждой доле и число рёбер соответственно.  
Во второй строке записаны \(N\) чисел \(a_i\) (\(1 \leq a_i \leq 10^4\)).  
В третьей строке записаны \(N\) чисел \(b_i\) (\(1 \leq b_i \leq 10^4\)).  
В каждой из последующих \(M\) строк записаны пары чисел \(u, v\) (\(1 \leq u, v \leq N\)), означающие наличие ребра между вершиной \(u\) левой доли и вершиной \(v\) правой доли.

### Формат вывода
Выведите одно число — величину максимального потока.

### Пример

**Ввод**:
```
3 4
3 2 1
5 4 4
1 1
1 2
2 3
3 3
```

**Вывод**:
```
6
```

</details>

<details><summary> 
<strong>C. Эдмонс-Карп</strong>
</summary>

### C. Эдмонс-Карп

**Ограничение времени**: 1 секунда  
**Ограничение памяти**: 256Mb  
**Ввод**: стандартный ввод или input.txt  
**Вывод**: стандартный вывод или output.txt

Задан ориентированный граф, каждое ребро которого обладает целочисленной пропускной способностью. Найдите максимальный поток из вершины с номером 1 в вершину с номером \(n\). В этой задаче необходимо реализовать алгоритм Эдмонса-Карпа.

### Формат ввода
Первая строка входного файла содержит \(n\) и \(m\) — количество вершин и количество рёбер графа (\(2 \leq n \leq 500\), \(1 \leq m \leq 10000\)).  
Следующие \(m\) строк содержат по три числа: номера вершин, которые соединяет соответствующее ребро графа и его пропускную способность. Пропускные способности не превосходят \(10^9\).

### Формат вывода
В выходной файл выведите одно число — величину максимального потока из вершины с номером 1 в вершину с номером \(n\).

### Пример

**Ввод**:
```
4 5
1 2 1
1 3 2
3 2 1
2 4 2
3 4 1
```

**Вывод**:
```
3
```

###### *Решение: [\*тык\*](c.cpp) (не доделано)*

</details>

###### *Конспект лекции: [\*тык\*](aads-lecture-10.pdf)*
###### *Запись лекции: [\*тык\*](https://youtu.be/oiK1hWRfRlE)*
# Восьмая неделя. Графы. Миностовы. Прима. Краскал. Геометрия (C++).

## Задачи

<details><summary> 
<strong>A. Острова</strong>
</summary>

### A. Острова

Ограничение времени: 0.5 секунд  
Ограничение памяти: 16Mb

**Ввод**  
стандартный ввод или input.txt

**Вывод**  
стандартный вывод или output.txt

Одно разбросанное на островах Океании государство решило создать сеть автомобильных дорог (вернее, мостов). По каждому мосту можно перемещаться в обе стороны. Был разработан план очередности строительства мостов и известно, что после постройки всех мостов можно будет проехать по ним с каждого острова на каждый (возможно, через некоторые промежуточные острова).

Однако, этот момент может наступить до того, как будут построены все мосты. Ваша задача состоит в определении такого минимального количества мостов, после постройки которого (в порядке строительства по плану) можно будет попасть с любого острова на любой другой.

**Формат ввода**  
Первая строка содержит два числа: N — число островов (1 ≤ N ≤ 100000) и M — количество мостов в плане (1 ≤ M ≤ 200000). В каждой следующей строке содержится описание моста — два числа x и y (0 ≤ x, y < N) — номера соединяемых островов.

**Формат вывода**  
Выведите в выходной файл одно число — минимальное количество построенных мостов, по которым можно попасть с любого острова на любой.

**Пример**  
*Ввод*
```
4 5
0 1
0 2
1 2
2 3
3 0
```
*Вывод*
```
4
```

###### *Решение: [\*тык\*](a.cpp) (не доделано)*

</details>

<details><summary> 
<strong>B. Вес компоненты</strong>
</summary>

### B. Вес компоненты

Ограничение времени: 1 секунда  
Ограничение памяти: 32Mb

**Ввод**  
стандартный ввод или input.txt

**Вывод**  
стандартный вывод или output.txt

В неориентированный взвешенный граф добавляют ребра. Напишите программу, которая в некоторые моменты находит сумму весов ребер в компоненте связности.

**Формат ввода**  
В первой строке записано два числа n и m (1 ≤ n, m ≤ 10^6) — количество вершин в графе и количество производимых добавлений и запросов. Далее следует m строк с описанием добавления или запроса. Каждая строка состоит из двух или четырех чисел.

- Если первое число 1, то за ним следует еще три числа x, y, w. Это означает, что в граф добавляется ребро xy веса w (1 ≤ x < y ≤ n, 1 ≤ w ≤ 1000). Кратные ребра допустимы.
- Если первое число 2, то за ним следует ровно одно число x. Это означает, что необходимо ответить на вопрос, какова сумма весов ребер в компоненте связности, которой принадлежит вершина x (1 ≤ x ≤ n).

**Формат вывода**  
Для каждой операции с кодом 2 выведите ответ на поставленную задачу. Ответ на каждый запрос выводите на отдельной строке.

**Пример**  
*Ввод*
```
6 10
2 1
1 1 2 1
2 1
1 2 4 2
2 1
1 1 4 3
2 1
1 3 5 3
2 5
2 6
0
1
3
6
3
0
```
*Вывод*
```
0
1
3
6
3
0
```

</details>

<details><summary> 
<strong>C. Прим</strong>
</summary>

### C. Прим

Ограничение времени: 0.5 секунд  
Ограничение памяти: 32Mb

**Ввод**  
стандартный ввод или input.txt

**Вывод**  
стандартный вывод или output.txt

Требуется найти в связном графе остовное дерево минимального веса. Задачу решайте с помощью алгоритма Прима.

**Формат ввода**  
Первая строка входного файла содержит два натуральных числа n и m — количество вершин и ребер графа соответственно (1 ≤ n ≤ 20000, 0 ≤ m ≤ 100000). Следующие m строк содержат описание ребер по одному на строке. Ребро номер i описывается тремя натуральными числами bi, ei и wi — номера концов ребра и его вес соответственно (1 ≤ bi, ei ≤ n, 0 ≤ wi ≤ 100000).

**Формат вывода**  
Выведите единственное целое число — вес минимального остовного дерева.

**Пример**  
*Ввод*
```
4 4
1 2 1
2 3 2
3 4 5
4 1 4
```
*Вывод*
```
7
```

###### *Решение: [\*тык\*](c.cpp)*

</details>

<details><summary> 
<strong>D. Точки сочленения</strong>
</summary>

### D. Краскал

Ограничение времени: 1.5 секунд  
Ограничение памяти: 128Mb

**Ввод**  
стандартный ввод или input.txt

**Вывод**  
стандартный вывод или output.txt

Дан связный неориентированный граф, в котором надо найти остовное дерево минимального веса с помощью алгоритма Краскала. Гарантируется, что ребра будут отсортированы по весу по неубыванию.

**Формат ввода**  
Первая строка содержит два натуральных числа N и M (2 ≤ N ≤ 5 ⋅ 10^4, 1 ≤ M ≤ 2 ⋅ 10^6) — количество вершин и ребер графа соответственно. Следующие M строк содержат описание ребер в формате u, v, w (1 ≤ u < v ≤ N, 1 ≤ w ≤ 10^4) — ребро между вершинами u и v веса w.

**Формат вывода**  
Выведите вес минимального остовного дерева.

**Пример**  
*Ввод*
```
7 12
1 5 2
5 7 3
4 7 3
5 6 6
2 7 6
4 6 7
4 5 8
3 6 8
3 4 8
2 6 9
2 5 10
3 5 10
```
*Вывод*
```
28
```

###### *Решение: [\*тык\*](d.cpp)*

</details>

<details><summary> 
<strong>C++. Геометрия</strong>
</summary>

### C++. Геометрия

**Ограничение времени**: 1 секунда  
**Ограничение памяти**: 256Mb  
**Ввод**: стандартный ввод или input.txt  
**Вывод**: стандартный вывод или output.txt

Написать класс `Vector` для вектора на плоскости, реализовав основные действия над векторами в виде методов и переопределения операций.

Создать также набор классов — фигур, которые наследуются от абстрактного базового класса `AbstractShape` для работы с двумерными геометрическими примитивами:
- `Point` (точка);
- `Segment` (отрезок);
- `Line` (прямая);
- `Ray` (луч);
- `Polygon` (простой многоугольник — часть плоскости, ограниченная замкнутой ломаной без самопересечений).
- `Circle` (круг)

В базовом классе предусмотреть виртуальные методы:
- сдвига на заданный вектор;
- проверки, содержит ли фигура точку;
- проверки, пересекается ли она с отрезком;
- копирования данного объекта;
- вывода в `cout` данного объекта.

В производных классах — реализовать эти методы.

В этой задаче нужно определить все классы, методы, функции так, чтобы предложенный тестирующий код выводил ожидаемый результат в соответствии с общепринятой семантикой. Исправлять код функций `main` и `CheckFunctions` запрещается.

**Тесты**:
- 1-6 совпадают с примером
- 7-15 point
- 16-46 segment
- 47-55 ray
- 56-60 line
- 61-71 polygon
- 72-80 circle

**Формат ввода**:
В первой строчке задается тип геометрического примитива: «point», «segment», «ray», «line», «circle» или «polygon». Далее вводится сам примитив.
После чего вводится две точки A и B, которые используются в `CheckFunctions`. Все числа целочисленные и не превосходят 10000 по модулю.
Для `Point` выводятся ее координаты; `Segment` - два конца (точки); `Ray` - начало (точка) и лежащая на луче точка; `Line` - две точки, через которые проходит прямая; `Polygon` - последовательность вершин; `Circle` - центр и радиус.

**Формат вывода**:
Формат вывода можно посмотреть в `main` и в примерах.

Пример 1:
Ввод:
```
point
0 0
-1 -1 1 1
```

Вывод:
```
Given shape does not contain point A
Given shape crosses segment AB
2 2
```

Пример 2:
Ввод:
```
segment
0 -1 0 1
0 0 0 1
```

Вывод:
```
Given shape contains point A
Given shape crosses segment AB
0 0 0 2
```

Пример 3:
Ввод:
```
ray
0 0 1 1
2 2 3 2
```

Вывод:
```
Given shape contains point A
Given shape crosses segment AB
1 0 2 1
```

Пример 4:
Ввод:
```
line
0 0 0 1
1 1 2 1
```

Вывод:
```
Given shape does not contain point A
Given shape does not cross segment AB
1 0 1 1
```

Пример 5:
Ввод:
```
polygon
4
0 0 3 0 3 3 0 3
1 1 2 2
```

Вывод:
```
Given shape contains point A
Given shape does not cross segment AB
4
1 1 4 1 4 4 1 4
```

Пример 6:
Ввод:
```
circle
0 0 5
0 0 5 5
```

Вывод:
```
Given shape contains point A
Given shape crosses segment AB
5 5 5
```

**Примечания**:
- Старайтесь избегать использования чисел с плавающей точкой.
- Используйте задачи этого контеста для тестирования некоторых функций.
- В данной задаче многоугольник содержит точку, если она лежит в части плоскости, ограниченной замкнутой ломаной. Многоугольник пересекается с отрезком, если отрезок пересекается с замкнутой кривой.
- Круг пересекается с отрезком, если есть точка отрезка, лежащая на границе круга. Круг содержит точку, если она лежит внутри круга или на окружности.

###### *Решение: [\*тык\*](geometry.cpp)*

</details>

###### *Конспект лекции: [\*тык\*](aads-lecture-8.pdf)*
###### *Запись лекции: [\*тык\*](https://youtu.be/Aa2Vh_qwP_s)*
### 1. Базовые конструкции

#### (a) Алфавит языка. Ключевые слова. Идентификаторы. Литералы. Знаки операций.
- **Алфавит языка:** состоит из букв латинского алфавита (A-Z, a-z), цифр (0-9), символов подчеркивания (_), пробелов и специальных символов.
- **Ключевые слова:** зарезервированные слова, например, `int`, `return`, `if`, `else`, `while`, `for`, `switch`, `case`, `default`, `break`, `continue`, `class`, `public`, `private`, `protected`, `static`, `const`, `virtual`, `override`, `final`, и т.д.
- **Идентификаторы:** пользовательские имена для переменных, функций, классов и т.д. Должны начинаться с буквы или символа подчеркивания, и могут содержать буквы, цифры и символ подчеркивания.
- **Литералы:** константные значения, например, числовые (`42`, `3.14`), символьные (`'a'`), строковые (`"hello"`), логические (`true`, `false`).
- **Знаки операций:** операторы, например, арифметические (`+`, `-`, `*`, `/`, `%`), логические (`&&`, `||`, `!`), сравнения (`==`, `!=`, `<`, `>`, `<=`, `>=`), побитовые (`&`, `|`, `^`, `~`, `<<`, `>>`), присваивания (`=`, `+=`, `-=`, `*=`, `/=`, `%=`).

#### (b) Структура программы на C++. Объявления и определения. Операторы. Комментарии.
- **Структура программы:** включает директивы препроцессора (#include), объявления и определения функций и переменных, основной блок программы (`int main() {}`).
- **Объявления и определения:** Объявление сообщает компилятору о существовании идентификатора (например, `extern int x;`), а определение выделяет память (например, `int x = 5;`).
- **Операторы:** инструкции, выполняющие действия (например, присваивание, арифметические операции, условные выражения).
- **Комментарии:** однострочные (`//`) и многострочные (`/* ... */`).

#### (c) Концепция типа данных. Фундаментальные типы данных: целые типы, символьный тип, логический тип, типы с плавающей точкой, void. Операции над фундаментальными типами.
- **Концепция типа данных:** Тип данных определяет множество значений и операции, которые могут быть выполнены с этими значениями.
- **Фундаментальные типы данных:**
    - **Целые типы:** `int`, `short`, `long`, `long long`, их знаковые и беззнаковые варианты (`signed`, `unsigned`).
    - **Символьный тип:** `char`, `wchar_t`, `char16_t`, `char32_t`.
    - **Логический тип:** `bool`.
    - **Типы с плавающей точкой:** `float`, `double`, `long double`.
    - **void:** специальный тип для указания на отсутствие типа.
- **Операции над фундаментальными типами:** арифметические операции, операции сравнения, логические операции, побитовые операции.

#### (d) Переменные. Классы памяти и области действия. Область видимости. Инициализация. CV-квалификаторы.
- **Переменные:** именованные области памяти для хранения данных.
- **Классы памяти:** `automatic` (локальные переменные), `static` (статические переменные), `dynamic` (динамически выделенная память), `thread_local`.
- **Область действия:** блок кода, в пределах которого переменная доступна.
- **Инициализация:** присваивание начального значения переменной (например, `int x = 0;`).
- **CV-квалификаторы:** `const` (константность), `volatile` (предотвращение оптимизаций).

#### (e) Выражения. Особенности работы операций. Категории значения. static_cast, sizeof.
- **Выражения:** комбинации переменных, литералов и операторов, которые вычисляются в значение (например, `a + b`).
- **Особенности работы операций:** приоритет и ассоциативность операций.
- **Категории значения:** lvalue (объект, к которому можно получить адрес), rvalue (значение, к которому нельзя получить адрес).
- **static_cast:** явное приведение типов.
- **sizeof:** оператор для получения размера типа или объекта в байтах (например, `sizeof(int)`).

### 2. Операторы управления

#### (a) Условная операция (?:). Условный оператор (if-else).
- **Условная операция (?:):** тернарный оператор, который возвращает одно из двух значений в зависимости от условия (например, `int x = (a > b) ? a : b;`).
- **Условный оператор (if-else):** позволяет выполнять блок кода в зависимости от условия (например, `if (a > b) { /* код */ } else { /* код */ }`).

#### (b) Циклы: while, do-while, for.
- **while:** выполняет блок кода, пока условие истинно (например, `while (x < 10) { x++; }`).
- **do-while:** выполняет блок кода хотя бы один раз, затем повторяет выполнение, пока условие истинно (например, `do { x++; } while (x < 10);`).
- **for:** выполняет блок кода определенное количество раз (например, `for (int i = 0; i < 10; i++) { /* код */ }`).

#### (c) Оператор switch.
- **switch:** позволяет выполнить одну из нескольких возможных ветвей кода в зависимости от значения выражения (например, `switch (x) { case 1: /* код */ break; case 2: /* код */ break; default: /* код */ }`).

#### (d) Операторы break и continue. Оператор безусловного перехода.
- **break:** завершает выполнение ближайшего внешнего цикла или оператора switch.
- **continue:** пропускает оставшуюся часть текущей итерации цикла и переходит к следующей итерации.
- **Оператор безусловного перехода:** `goto`, который позволяет передать управление к указанной метке в пределах функции (например, `goto label;` ... `label: /* код */`).

### 3. Массивы и указатели

#### (a) Операция взятия адреса. Указатели. Разыменовывание указателя. Арифметика указателей. Константные указатели и указатели на константы. Нулевой указатель. Провисший указатель.
- **Операция взятия адреса:** `&` оператор для получения адреса переменной (например, `int *p = &x;`).
- **Указатели:** переменные, хранящие адреса других переменных (например, `int *p;`).
- **Разыменовывание указателя:** `*` оператор для доступа к значению по адресу, хранящемуся в указателе (например, `int y = *p;`).
- **Арифметика указателей:** операции с указателями (например, `p++`, `p + 1`, `p - 1`).
- **Константные указатели и указатели на константы:** указатели, адреса которых нельзя изменить, и указатели, указывающие на неизменяемые значения.
- **Нулевой указатель:** указатель, не указывающий ни на какой объект (например, `nullptr`).
- **Провисший указатель:** указатель, указывающий на освобожденную область памяти.

#### (b) Ссылки. Правила работы со ссылками. Ссылки на константу.
- **Ссылки:** алиасы для других переменных (например, `int &ref = x;`).
- **Правила работы со ссылками:** ссылки должны быть инициализированы при объявлении и не могут быть перенаправлены.
- **Ссылки на константу:** ссылки, указывающие на неизменяемые значения (например, `const int &ref = x;`).

#### (c) Массивы в стиле C. Операции над массивами. Инициализация массивов. Связь массивов и указателей. Указатель на массив. Многомерные массивы.
- **Массивы в стиле C:** фиксированные наборы однотипных элементов (например, `int arr[10];`).
- **Операции над массивами:** доступ к элементам массива, итерация по массиву.
- **Инициализация массивов:** присваивание начальных значений элементам массива (например, `int arr[3] = {1, 2, 3};`).
- **Связь массивов и указателей:** имя массива является указ

ателем на его первый элемент.
- **Указатель на массив:** указатель, указывающий на весь массив (например, `int (*p)[10] = &arr;`).
- **Многомерные массивы:** массивы массивов (например, `int matrix[3][3];`).

#### (d) Динамическая память. Выражения new и delete. Динамические массивы.
- **Динамическая память:** память, выделяемая и освобождаемая во время выполнения программы с помощью `new` и `delete` (например, `int *p = new int; delete p;`).
- **Динамические массивы:** массивы, создаваемые и удаляемые во время выполнения программы (например, `int *arr = new int[10]; delete[] arr;`).

#### (e) Строковые литералы. Строки в стиле C. Функции для работы со строками (<cstring>).
- **Строковые литералы:** последовательности символов, заключенные в двойные кавычки (например, `"hello"`).
- **Строки в стиле C:** массивы символов, оканчивающиеся нулевым символом (`\0`).
- **Функции для работы со строками:** функции библиотеки `<cstring>` для манипуляции строками (например, `strcpy`, `strlen`, `strcmp`).

### 4. Функции

#### (a) Функции. Объявление и определение. Возвращаемое значение, аргументы, аргументы по умолчанию.
- **Функции:** блоки кода, выполняющие определенную задачу.
- **Объявление и определение:** Объявление функции сообщает компилятору о её существовании, а определение содержит код функции (например, `int sum(int a, int b);` и `int sum(int a, int b) { return a + b; }`).
- **Возвращаемое значение:** тип данных, который возвращает функция (например, `int`).
- **Аргументы:** входные данные функции (например, `(int a, int b)`).
- **Аргументы по умолчанию:** аргументы с заданными значениями по умолчанию (например, `void func(int a = 10);`).

#### (b) Перегрузка функций. Статические переменные функции.
- **Перегрузка функций:** создание нескольких функций с одинаковым именем, но разными параметрами (например, `int sum(int a, int b);` и `double sum(double a, double b);`).
- **Статические переменные функции:** переменные, сохраняющие своё значение между вызовами функции (например, `static int count = 0;`).

#### (c) Передача и возврат указателей, ссылок и массивов в/из функции.
- **Передача указателей:** позволяет функции изменять значения переменных, на которые указывают указатели (например, `void func(int *p);`).
- **Передача ссылок:** позволяет функции изменять значения аргументов, переданных по ссылке (например, `void func(int &ref);`).
- **Передача массивов:** передача указателя на первый элемент массива (например, `void func(int arr[]);`).
- **Возврат указателей, ссылок и массивов:** возврат указателей и ссылок из функций (например, `int* func();`).

#### (d) Рекурсия: прямая, косвенная. Примеры рекурсивных вычислений.
- **Прямая рекурсия:** функция вызывает сама себя (например, вычисление факториала).
- **Косвенная рекурсия:** функция вызывает другую функцию, которая в свою очередь вызывает первую (например, `void A() { B(); } void B() { A(); }`).
- **Примеры рекурсивных вычислений:** вычисление факториала, числа Фибоначчи.

### 5. Пользовательские типы

#### (a) Перечисления (enum)
- **Перечисления:** пользовательский тип данных, состоящий из набора именованных констант (например, `enum Color { RED, GREEN, BLUE };`).

#### (b) Объединения (union)
- **Объединения:** пользовательский тип данных, позволяющий хранить разные типы данных в одной и той же области памяти (например, `union Data { int i; float f; };`).

#### (c) Структуры (struct)
- **Структуры:** пользовательский тип данных, позволяющий объединять данные разных типов (например, `struct Point { int x; int y; };`).

### 6. Шаблоны

#### (a) Шаблоны функций. Шаблоны классов. Шаблоны переменных. Шаблоны псевдонимов типов (using).
- **Шаблоны функций:** позволяют создавать функции, работающие с разными типами данных (например, `template <typename T> T sum(T a, T b);`).
- **Шаблоны классов:** позволяют создавать классы, работающие с разными типами данных (например, `template <typename T> class Array;`).
- **Шаблоны переменных:** позволяют создавать переменные шаблонов (например, `template <typename T> T value;`).
- **Шаблоны псевдонимов типов:** позволяют создавать псевдонимы типов (например, `template <typename T> using Ptr = T*;`).

#### (b) Вывод типа аргумента шаблона. Параметры шаблона по умолчанию. Перегрузка шаблонов функций. Объявление auto переменных.
- **Вывод типа аргумента шаблона:** автоматическое определение типа аргумента шаблона на основе переданного значения (например, `auto x = sum(1, 2);`).
- **Параметры шаблона по умолчанию:** задание значений по умолчанию для параметров шаблона (например, `template <typename T = int> class Array;`).
- **Перегрузка шаблонов функций:** создание нескольких шаблонных функций с одинаковым именем, но разными параметрами (например, `template <typename T> T sum(T a, T b); template <typename T> T sum(T a, T b, T c);`).
- **Объявление auto переменных:** использование ключевого слова `auto` для автоматического определения типа переменной (например, `auto x = 5;`).

#### (c) Специализация шаблонов. Инстанцирование шаблонов.
- **Специализация шаблонов:** создание специализированных версий шаблонов для определенных типов данных (например, `template <> class Array<char>;`).
- **Инстанцирование шаблонов:** создание конкретных экземпляров шаблонов (например, `Array<int> arr;`).

### 7. Классы. Начало

#### (a) Парадигмы программирования. Объектно-ориентированное программирование. Абстракция, инкапсуляция, полиморфизм, наследование.
- **Парадигмы программирования:** различные подходы к программированию (например, процедурное, объектно-ориентированное, функциональное).
- **Объектно-ориентированное программирование:** парадигма, основанная на объектах и классах.
    - **Абстракция:** выделение значимых характеристик объекта, исключая незначимые.
    - **Инкапсуляция:** сокрытие внутренней реализации объекта и предоставление интерфейса для взаимодействия с ним.
    - **Полиморфизм:** способность объектов различных классов реагировать на одни и те же сообщения по-разному.
    - **Наследование:** создание нового класса на основе существующего с добавлением новых или изменением существующих характеристик.

#### (b) Классы и объекты. Поля и методы. Модификаторы доступа. Друзья класса.
- **Классы и объекты:** классы определяют структуру и поведение объектов.
- **Поля и методы:** поля — переменные класса, методы — функции класса.
- **Модификаторы доступа:** определяют уровень доступа к полям и методам (`public`, `private`, `protected`).
- **Друзья класса:** функции или классы, имеющие доступ к приватным и защищенным членам класса (например, `friend class B;`).

#### (c) Константные и статические поля и методы. Логическая и физическая константность. Ключевое слово mutable.
- **Константные поля и методы:** не изменяют состояния объекта (`const`).
- **Статические поля и методы:** принадлежат классу, а не экземпляру класса (`static`).
- **Логическая и физическая константность:** логическая константность — не изменяет логическое состояние объекта, физическая — не изменяет его физическое состояние.
- **Ключевое слово mutable:** позволяет изменять поля в константных методах.

### 8. Конструкторы и деструктор

#### (a) Агрегатная инициализация. Конструктор. Виды конструкторов. Списки инициализации. Делегирующие конструкт

оры. Ключевое слово explicit.
- **Агрегатная инициализация:** инициализация объектов с помощью списка инициализаторов (например, `Point p = {1, 2};`).
- **Конструктор:** специальная функция, вызываемая при создании объекта.
    - **Виды конструкторов:** конструктор по умолчанию, параметризованный конструктор, конструктор копирования.
- **Списки инициализации:** список инициализации полей в конструкторе (например, `Point(int x, int y) : x(x), y(y) {}`).
- **Делегирующие конструкторы:** конструкторы, вызывающие другие конструкторы (например, `Point() : Point(0, 0) {}`).
- **Ключевое слово explicit:** предотвращает неявное преобразование типов при вызове конструктора.

#### (b) Конструкции = default и = delete.
- **Конструкции = default и = delete:** позволяют явно указывать, что конструктор или метод должны быть автоматически сгенерированы компилятором или удалены (например, `Point() = default; Point(const Point&) = delete;`).

#### (c) Деструктор. Идиома RAII. Порядок вызова конструкторов и деструкторов. Правило трех.
- **Деструктор:** специальная функция, вызываемая при удалении объекта (например, `~Point();`).
- **Идиома RAII (Resource Acquisition Is Initialization):** управление ресурсами через объекты, которые захватывают ресурсы в своих конструкторах и освобождают в деструкторах.
- **Порядок вызова конструкторов и деструкторов:** сначала вызываются конструкторы базовых классов, затем производных. При уничтожении объекта порядок обратный.
- **Правило трех:** если класс требует явного определения конструктора копирования, оператора присваивания и деструктора, следует определить все три.

### 9. Сборка программ на C++ и перегрузка операций

#### (a) Перегрузка операций. Правила перегрузки операций. Перегрузка побитового сдвига для потокового ввода/вывода.
- **Перегрузка операций:** позволяет определять новые версии операторов для пользовательских типов (например, `Point operator+(const Point& lhs, const Point& rhs);`).
- **Правила перегрузки операций:** некоторые операторы не могут быть перегружены (например, `.` и `.*`).
- **Перегрузка побитового сдвига для потокового ввода/вывода:** перегрузка операторов `<<` и `>>` для работы с потоками (например, `std::ostream& operator<<(std::ostream& os, const Point& p);`).

#### (b) One Definition Rule. Директива #include, проблема двойного включения, стражи включения.
- **One Definition Rule (ODR):** правило, гласящее, что в программе может быть только одно определение каждой функции или переменной.
- **Директива #include:** вставка содержимого одного файла в другой (например, `#include <iostream>`).
- **Проблема двойного включения:** включение одного и того же файла несколько раз, что может вызвать ошибки.
- **Стражи включения:** предотвращение двойного включения с помощью препроцессорных директив (например, `#ifndef HEADER_H #define HEADER_H ... #endif`).

#### (c) Сборка программ на C++. Раздельная компиляция, модули (до C++20). Встраиваемые функции и переменные. Внутреннее и внешнее связывание (static, extern).
- **Сборка программ на C++:** процесс компиляции и линковки, создающий исполняемый файл.
- **Раздельная компиляция:** компиляция отдельных файлов независимо друг от друга.
- **Модули (до C++20):** единицы компиляции, определяющие интерфейс и реализацию.
- **Встраиваемые функции и переменные:** функции и переменные, определенные с ключевым словом `inline`.
- **Внутреннее и внешнее связывание:** управление областью видимости и временем жизни переменных и функций (`static` для внутреннего связывания, `extern` для внешнего).

#### (d) Пространства имен, директивы using и using namespace.
- **Пространства имен:** механизм для предотвращения конфликтов имен (например, `namespace myNamespace { ... }`).
- **Директива using:** позволяет использовать имена из пространства имен без полного квалификационного имени (например, `using myNamespace::myFunction;`).
- **Директива using namespace:** делает все имена из пространства имен доступными без полного квалификационного имени (например, `using namespace std;`).

### 10. Функциональные объекты и алгоритмы

#### (a) Функторы. Классы с перегруженной операцией функционального вызова. Лямбда-выражения.
- **Функторы:** объекты, которые можно вызывать как функции (например, класс с перегруженной оператором `()`).
- **Лямбда-выражения:** анонимные функции, которые можно определять прямо в месте использования (например, `[](int x) { return x * x; }`).

#### (b) Алгоритмы. Модифицирующие алгоритмы. Немодифицирующие алгоритмы. Алгоритмы сортировки. Алгоритмы упорядоченных последовательностей. Алгоритмы для работы с пирамидой.
- **Алгоритмы:** функции из библиотеки `<algorithm>`, выполняющие общие операции над контейнерами (например, `std::sort`, `std::for_each`).
- **Модифицирующие алгоритмы:** изменяют содержимое контейнера (например, `std::transform`).
- **Немодифицирующие алгоритмы:** не изменяют содержимое контейнера (например, `std::find`).
- **Алгоритмы сортировки:** сортируют элементы контейнера (например, `std::sort`, `std::stable_sort`).
- **Алгоритмы упорядоченных последовательностей:** работают с отсортированными контейнерами (например, `std::binary_search`, `std::merge`).
- **Алгоритмы для работы с пирамидой:** работают с пирамидальными структурами данных (например, `std::make_heap`, `std::pop_heap`).

### 11. Контейнеры

#### (a) Последовательные контейнеры: std::array, std::vector, std::deque, std::list, std::forward_list, std::initializer_list.
- **Последовательные контейнеры:** хранят элементы в определенном порядке.
    - **std::array:** фиксированный массив.
    - **std::vector:** динамический массив.
    - **std::deque:** двусторонняя очередь.
    - **std::list:** двусвязный список.
    - **std::forward_list:** односвязный список.
    - **std::initializer_list:** список инициализаторов.

#### (b) Ассоциативные контейнеры: std::map, std::set. unordered- и multi- версии. Structured bindings.
- **Ассоциативные контейнеры:** хранят элементы в виде пар ключ-значение.
    - **std::map:** отображение, упорядоченное по ключам.
    - **std::set:** множество, упорядоченное по ключам.
    - **unordered- и multi- версии:** неупорядоченные и мультиверсии контейнеров (например, `std::unordered_map`, `std::multiset`).
- **Structured bindings:** механизм, позволяющий распаковывать кортежи и пары в отдельные переменные (например, `auto [key, value] = pair;`).

#### (c) Контейнерные адаптеры: std::stack, std::queue, std::priority_queue.
- **Контейнерные адаптеры:** обеспечивают специфичные интерфейсы для работы с элементами.
    - **std::stack:** стек (LIFO).
    - **std::queue:** очередь (FIFO).
    - **std::priority_queue:** очередь с приоритетом.

### 12. Наследование и Статический полиморфизм

#### (a) Наследование. Модификаторы доступа при наследовании. Конструкторы и деструкторы при наследовании.
- **Наследование:** механизм, позволяющий создавать новые классы на основе существующих.
- **Модификаторы доступа при наследовании:** определяют доступ к базовым классам (`public`, `protected`, `private`).
- **Конструкторы и деструкторы при наследовании:** порядок вызова конструкторов и деструкторов в иерархии наследования.

#### (b) Срезка. Затенение методов базового класса. Работа с производными классами через указатель или ссылку на базовый.
- **Срезка:** потеря данных при присваивании объекта производного класса объекту базового класса.
- **Затенение методов базового класса:** методы базового класса, перекрытые методами производного класса.
- **Работа с производными классами через указатель или ссылку на базовый:** использование полиморфизма для работы с объектами различных классов через единый интерфейс.

#### (c) Виртуальные функции. Чисто виртуальные функции и абстрактные классы. Позднее связывание.
- **Виртуальные функции:** функции, которые могут быть переопределены в производных классах.
- **Чисто виртуальные функции и абстрактные классы:** функции без определения, делающие класс абстрактным (например, `virtual void func() = 0;`).
- **Позднее связывание:** определение метода, который будет вызван только во время выполнения программы, а не во время компиляции.

### 13. Динамическое полиморфизм и Управление ресурсами

#### (a) Виртуальные деструкторы. Утечки памяти и управление ресурсами.
- **Виртуальные деструкторы:** деструкторы, объявленные как виртуальные для правильного удаления производных классов через указатель на базовый класс.
- **Утечки памяти и управление ресурсами:** обеспечение освобождения выделенной памяти и других ресурсов при удалении объектов.

#### (b) Умные указатели: std::unique_ptr, std::shared_ptr, std::weak_ptr. Семантика перемещения.
- **Умные указатели:** классы-обертки над указателями, предоставляющие управление жизненным циклом объектов.
    - **std::unique_ptr:** уникальный владелец объекта.
    - **std::shared_ptr:** разделяемый владелец объекта.
    - **std::weak_ptr:** наблюдатель объекта, не влияющий на его жизненный цикл.
- **Семантика перемещения:** передача ресурсов между объектами, минимизируя копирование данных.

#### (c) Динамическое полиморфизм через интерфейсы и абстрактные классы.
- **Динамическое полиморфизм через интерфейсы и абстрактные классы:** использование абстрактных классов для создания интерфейсов, которые реализуют производные классы.

### 14. Исключения и Потоки

#### (a) Исключения. try, catch, throw. Спецификации исключений. Стандартные исключения.
- **Исключения:** механизм обработки ошибок, позволяющий отделить код обработки ошибок от основного кода.
    - **try, catch, throw:** блоки для генерации и обработки исключений.
    - **Спецификации исключений:** описания типов исключений, которые может выбрасывать функция (устаревший подход).
    - **Стандартные исключения:** классы исключений стандартной библиотеки (например, `std::runtime_error`, `std::invalid_argument`).

#### (b) Потоки ввода/вывода. std::cin, std::cout, std::cerr, std::clog. Работа с файлами.
- **Потоки ввода/вывода:** механизмы для работы с вводом и выводом данных.
    - **std::cin:** стандартный входной поток.
    - **std::cout:** стандартный выходной поток.
    - **std::cerr:** стандартный поток ошибок.
    - **std::clog:** стандартный поток протоколирования.
- **Работа с файлами:** использование потоков для чтения и записи данных в файлы.

### 15. Многопоточное программирование

#### (a) Потоки и Операции синхронизации
- **Потоки:** параллельные задачи, выполняемые в рамках одного процесса.
- **Операции синхронизации:** механизмы для координации доступа к разделяемым ресурсам между потоками (например, `std::mutex`, `std::condition_variable`).

#### (b) std::thread и std::mutex
- **std::thread:** класс для работы с потоками.
- **std::mutex:** мьютекс для обеспечения эксклюзивного доступа к ресурсам.

#### (c) std::async и std::future
- **std::async:** запуск асинхронной задачи.
- **std::future:** механизм для получения результата асинхронной операции.

#### (d) Синхронизация с std::condition_variable
- **std::condition_variable:** механизм для ожидания определенного условия в многопоточной среде.

### 16. Дополнительные возможности C++

#### (a) Работа с временем и датой
- **Работа с временем и датой:** функции и классы для работы с датами, временем и интервалами (например, `std::chrono`).

#### (b) Стандартная библиотека шаблонов
- **Стандартная библиотека шаблонов (STL):** коллекция шаблонов и алгоритмов, предоставляемая стандартной библиотекой C++ (например, контейнеры, алгоритмы, итераторы).

#### (c) Тестирование и отладка
- **Тестирование и отладка:** инструменты и методы для тестирования и отладки C++ программ (например, `assert`, `gtest`, `valgrind`).

#### (d) Производительность и оптимизация
- **Производительность и оптимизация:** техники и инструменты для повышения производительности программ (например, профилирование, оптимизация кода).

Этот список включает основные темы и концепции, которые могут быть полезны при подготовке к экзамену по C++. Если у вас есть конкретные вопросы или нужна дополнительная информация по каким-либо пунктам, не стесняйтесь спрашивать!
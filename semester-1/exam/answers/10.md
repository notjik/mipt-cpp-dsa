Heap - это полное бинарное дерево, в котором каждый узел больше или равен своим дочерним элементам. Это свойство делает
его идеальным для сортировки и реализации очередей с приоритетами.

Операции:
1. **Push**: Добавление элемента в кучу имеет сложность O(log(n)), где n - это количество элементов в куче. Это связано
   с тем, что в худшем случае элемент "всплывает" от листа до корня, что занимает log(n) шагов.

2. **PopMax**: Удаление максимального элемента также имеет сложность O(log(n)), поскольку после удаления корня последний
   элемент кучи перемещается в корень и затем "оседает" вниз до его правильного места, что в худшем случае занимает log(
   n) шагов.

3. **Heap Sort**: Сортировка кучей имеет сложность O(nlog(n)), где n - это размер массива. Это связано с тем,
   что для каждого из n элементов мы выполняем операцию удаления максимума (которая занимает log(n) времени),
   что в сумме дает nlog(n).

Доказательство этих асимптотических сложностей основывается на структуре кучи как полного бинарного дерева. В полном
бинарном дереве количество узлов удваивается на каждом уровне, поэтому количество уровней (или высота дерева) равно
log(n). Поэтому операции, которые требуют прохода от корня до листа или наоборот (такие как push и popMax), занимают
log(n) времени. Сортировка кучей выполняет операцию удаления максимума $$n$$ раз, поэтому ее сложность равна nlog(n).

```c++
// Функция для вычисления индекса левого дочернего элемента в куче для заданного индекса "index".
int LeftChild(int index) {
  return 2 * index + 1;
}

// Функция для вычисления индекса правого дочернего элемента в куче для заданного индекса "index".
int RightChild(int index) {
  return 2 * index + 2;
}

// Функция для вычисления индекса родительского элемента в куче для заданного индекса "index".
int Parent(int index) {
  return (index - 1) / 2;
}

void SiftDown(int* begin, int* end, int i) {
  // Определение размера подмассива для работы и вычисление его текущей длины.
  int _size = end - begin;

  while (i < _size) {
    // Инициализация индекса текущих элементов.
    int left_child = LeftChild(i);
    int right_child = RightChild(i);
    int id_max = i;

    // Если левый дочерний элемент существует и больше текущего максимального, обновляем индекс максимального.
    if (left_child < _size && *(begin + left_child) > *(begin + id_max)) {
      id_max = left_child;
    }

    // Если правый дочерний элемент существует и больше текущего максимального, обновляем индекс максимального.
    if (right_child < _size && *(begin + right_child) > *(begin + id_max)) {
      id_max = right_child;
    }

    // Если текущий элемент не максимальный, меняем его местами с максимальным и обновляем индекс.
    if (i != id_max) {
      std::swap(*(begin + i), *(begin + id_max));
      i = id_max;
    }
      // Иначе завершаем процесс просеивания, так как свойство кучи восстановлено.
    else {
      break;
    }
  }
}

void BuildHeap(int* begin, int* end) {
  // Определение размера массива исходных данных.
  int _size = end - begin;

  // Перебираем элементы массива, начиная с середины и идя к началу.
  for (int i = (_size - 1) / 2; i >= 0; i--) {
    // Применяем процедуру просеивания для каждого элемента, чтобы построить кучу (heapify).
    SiftDown(begin, end, i);
  }
}

void HeapSort(int* begin, int* end) {
  // Определение размера массива.
  int _size = end - begin;

  // Строим кучу из массива.
  BuildHeap(begin, end);

  for (int i = _size - 1; i > 0; i--) {
    // Обмениваем максимальный элемент с последним элементом в массиве (popMin).
    std::swap(*(begin), *(begin + i));

    // Уменьшаем размер кучи и восстанавливаем свойство кучи (popMin).
    SiftDown(begin, --end, 0);
  }
}
```
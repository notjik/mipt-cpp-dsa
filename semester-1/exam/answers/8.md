**Сортировка подсчетом** - это алгоритм сортировки, который использует знание о диапазоне чисел в массиве для быстрой
сортировки. Он работает, подсчитывая количество каждого элемента, а затем используя эти подсчеты для определения позиции
каждого элемента в отсортированном массиве.
**Устойчивая сортировка подсчетом** - это вариация сортировки подсчетом, которая сохраняет относительный порядок равных
элементов в отсортированном массиве. Это достигается путем обратного прохода по входному массиву при формировании
отсортированного массива.
**Доказательство асимптотик и корректности:**

1. **Асимптотика:** Сортировка подсчетом работает за время O(n + k), где n - это количество элементов во входном
   массиве, а k - это разница между максимальным и минимальным элементами в массиве. Это делает его очень
   эффективным, когда k мало по сравнению с n. Затрачивает O(k) дополнительной памяти.
   Вот как мы можем доказать это:

    1. **Инициализация массива подсчета:** Мы создаем массив подсчета размером k + 1, где k - максимальное
       значение во входном массиве. Это занимает O(k) времени.

    2. **Подсчет элементов:** Мы проходим по входному массиву и увеличиваем соответствующий счетчик в массиве подсчета.
       Это занимает O(n) времени.

    3. **Формирование отсортированного массива:** Мы проходим по массиву подсчета и добавляем соответствующее количество
       каждого элемента в отсортированный массив. Это снова занимает O(n) времени.

2. **Корректность:** Сортировка подсчетом корректна, потому что она использует подсчеты каждого элемента для определения
   его позиции в отсортированном массиве. Поскольку каждый элемент помещается на правильную позицию в отсортированном
   массиве, итоговый массив будет отсортирован.

Таким образом, общее время выполнения сортировки подсчетом составляет O(n + k). Это делает его очень эффективным,
когда k мало по сравнению с n.

```c++
// Неустойчивая сортировка
void CountingSort(int* arr, int size) {
  int max = std::max(arr, size);
  int min = std::min(arr, size);
  int* count = new int[max - min + 1];
  for (int i = 0; i < max - min + 1; i++) {
    count[i] = 0;
  }
  for (int i = 0; i < size; i++) {
    count[arr[i] - min]++;
  }
  int index = 0;
  for (int i = 0; i < max - min + 1; i++) {
    while (count[i]-- > 0) {
      arr[index++] = i + min;
    }
  }
  delete[] count;
}
```

```c++
// Устойчивая сортировка
void CountingSort(int* arr, int size) {
  int max = std::max(arr, size);
  int min = std::min(arr, size);
  int* count = new int[max - min + 1];
  for (int i = 0; i < max - min + 1; i++) {
    count[i] = 0;
  }
  for (int i = 0; i < size; i++) {
    count[arr[i] - min]++;
  }
  for (int i = size - 1; i <= 0; i--) {
    arr[--count[arr[i] - min]] = arr[i];
  }
  delete[] count;
}
```

**Теорема о сортировках сравнением** утверждает, что любой алгоритм сортировки, который работает на основе сравнения, в
худшем случае имеет временную сложность $$O(nlog(n), где n - количество элементов для сортировки.

**Быстрая сортировка (Quick sort)** - это алгоритм сортировки, который использует принцип "разделяй и властвуй". Он
выбирает элемент, называемый опорным, и разбивает массив на две части: элементы, меньшие опорного, и элементы, большие
опорного. Затем он рекурсивно применяет этот процесс к каждой из двух частей.

**Выбор опорного** - это важный шаг в быстрой сортировке. От выбора опорного зависит эффективность алгоритма. Обычно
выбирают первый, последний или средний элемент массива, но есть и другие стратегии выбора.

**Разбиение Ломуто** - это один из способов разбиения в быстрой сортировке. Этот метод прост в реализации, но он менее
эффективен, чем разбиение Хоара. В методе разбиения Ломуто обычно выбирается последний элемент в качестве опорного.

Временная сложность быстрой сортировки в среднем случае составляет O(nlog(n)). Однако в худшем случае, когда
входные данные уже отсортированы или обратно отсортированы, быстрая сортировка имеет временную сложность O(n^2).

В сортировке Ломуто, чтобы минимизировать вероятность худшего случая (когда входные данные уже отсортированы или обратно
отсортированы), можно использовать стратегию выбора опорного элемента, которая уменьшает вероятность выбора "плохого"
опорного элемента.

Одним из подходов может быть **случайный выбор опорного элемента**. Это может быть достигнуто путем выбора случайного
элемента из массива и обмена его с последним элементом перед началом процедуры разбиения. Это гарантирует, что опорный
элемент будет случайным, что в среднем приведет к более сбалансированным разбиениям.

Другой подход - это использование **медианы трех**, где выбираются первый, средний и последний элементы, и в качестве
опорного используется их медиана. Этот метод также помогает уменьшить вероятность выбора "плохого" опорного элемента.

Однако стоит отметить, что эти методы увеличивают сложность алгоритма, так как требуют дополнительных операций для
выбора опорного элемента. Кроме того, они не гарантируют отсутствие худшего случая, но делают его менее вероятным.

Асимптотическая сложность быстрой сортировки с разбиением Ломуто в среднем случае составляет O(nlog(n)). Давайте
рассмотрим, почему это так.

Быстрая сортировка работает по принципу "разделяй и властвуй". Она разбивает массив на две части по опорному элементу, а
затем рекурсивно сортирует каждую из этих частей. Время, необходимое для сортировки массива размером n, можно
выразить следующим образом: T(n) = 2T(n/2) + O(n)

Здесь 2T(n/2) - это время, необходимое для рекурсивной сортировки двух подмассивов, а O(n) - это время,
необходимое для разбиения массива. Это уравнение соответствует рекуррентной формуле для O(nlog(n)).

Однако в худшем случае, когда входные данные уже отсортированы или одинаковы, разбиение Ломуто приводит к
тому, что один из подмассивов всегда пуст, а другой содержит все элементы, кроме опорного. В этом случае время работы
быстрой сортировки становится:

T(n) = T(n-1) + O(n)

Это уравнение соответствует рекуррентной формуле для O(n^2), что является худшим случаем для быстрой сортировки.

Таким образом, асимптотическая сложность быстрой сортировки с разбиением Ломуто составляет $$O(n \log n)$$ в среднем
случае и O(n^2) в худшем случае. Это можно предотвратить, используя более умный выбор опорного элемента, например,
выбирая медиану массива. Однако в методе разбиения Ломуто обычно выбирается последний элемент в качестве опорного.

```c++
int Partition(int* arr_, int left, int right) {
  int pivot = arr_[right];
  int i = (left - 1);
  for (int j = left; j < right; j++) {
    if (arr_[j] < pivot) {
      i++;
      std::swap(arr_[i], arr_[j]);
    }
  }
  std::swap(arr_[i + 1], arr_[right]);
  return i + 1;
}

void QuickSort(int* arr_, int left, int right) {
  if (left < right) {
    int pivotIndex = Partition(arr_, left, right);
    QuickSort(arr_, left, pivotIndex - 1);
    QuickSort(arr_, pivotIndex + 1, right);
  }
}
```
Поиск простых делителей. Алгоритм состоит в том, что мы перебираем все возможные делители числа от 2 до корня из числа и
проверяем, делятся ли они нацело. Если да, то это простой делитель. Сложность алгоритма составляет O(sqrt(n)), где n -
это исходное число.

Алгоритм поиска простых делителей состоит в том, что мы перебираем все возможные делители числа от 2 до корня из числа и
проверяем, делятся ли они нацело. Если да, то это простой делитель. Для доказательства асимптотики алгоритма, мы можем
использовать следующие факты:

- Любое составное число имеет простой делитель, не превосходящий его квадратного корня.
- Количество простых чисел, не превосходящих n, асимптотически равно n/ln(n) (теорема о распределении простых чисел).

Тогда, для нахождения всех простых делителей числа n, нам нужно проверить не более sqrt(n) чисел, из которых примерно
sqrt(n)/ln(sqrt(n)) являются простыми.
Следовательно, сложность алгоритма равна O(sqrt(n)*sqrt(n)/ln(sqrt(n))) = O(n/ln(n)).

```c++
#include <iostream>

// Функция, которая выводит все простые делители числа n
void print_prime_factors(int n) {
    // Перебираем все возможные делители от 2 до корня из n
    for (int i = 2; i * i <= n; i++) {
        // Пока i делит n нацело, выводим i и делим n на i
        while (n % i == 0) {
            cout << i << " ";
            n /= i;
        }
    }
    // Если n больше 1, значит остался еще один простой делитель - само n
    if (n > 1) {
        cout << n << " ";
    }
    cout << endl;
}
```

---
Проверка числа на простоту. Алгоритм аналогичен предыдущему, только вместо вывода делителей мы возвращаем логическое
значение - является ли число простым или нет. Сложность алгоритма также составляет O(sqrt(n)).

Алгоритм проверки числа на простоту состоит в том, что мы перебираем все возможные делители числа от 2 до корня из числа
и проверяем, делятся ли они нацело. Если да, то число составное, иначе простое. Для доказательства асимптотики
алгоритма, мы можем использовать следующий факт:

- Любое составное число имеет простой делитель, не превосходящий его квадратного корня1.

Тогда, для проверки числа n на простоту, нам нужно проверить не более sqrt(n) чисел. Следовательно, сложность алгоритма
равна O(sqrt(n)).

```c++
// Функция, которая проверяет, является ли число n простым
bool is_prime(int n) {
// Если n меньше или равно 1, то оно не простое
if (n <= 1) {
return false;
}
// Перебираем все возможные делители от 2 до корня из n
for (int i = 2; i <= sqrt(n); i++) {
// Если i делит n нацело, то n не простое
if (n % i == 0) {
return false;
}
}
// Если ни один делитель не найден, то n простое
return true;
}
```

---
Решето Эратосфена. Алгоритм состоит в том, что мы создаем массив булевых значений размером n+1, где n - это верхняя
граница интересующих нас простых чисел. Изначально все элементы массива равны true, кроме нулевого и первого. Затем
мы перебираем все числа от 2 до n и если очередное число i является простым (то есть соответствующий элемент массива
равен true), то мы отмечаем все его кратные как составные (то есть присваиваем соответствующим элементам массива
значение false). В итоге в массиве останутся только true на позициях простых чисел. Сложность алгоритма составляет
O(nloglogn).

Алгоритм решета Эратосфена позволяет находить все простые числа до некоторого целого числа n, отсеивая составные числа
по очереди. Для доказательства алгоритма, мы можем использовать следующие утверждения:

- Любое составное число имеет простой делитель, не превосходящий его квадратного корня.
- Количество простых чисел, не превосходящих n, асимптотически равно n/ln(n) (теорема о распределении простых чисел).

Тогда, для нахождения всех простых чисел до n, алгоритм состоит из следующих шагов:

- Выписать подряд все целые числа от двух до n.
- Пусть переменная p изначально равна двум — первому простому числу.
- Зачеркнуть в списке числа от 2p до n, считая шагами по p (это будут числа, кратные p).
- Найти первое незачёркнутое число в списке, большее чем p, и присвоить значению переменной p это число.
- Повторять шаги 3 и 4, пока p^2<=n.
- Теперь все незачёркнутые числа в списке — это все простые числа от 2 до n.

Для оценки сложности алгоритма, мы можем рассмотреть, сколько раз каждое число в списке будет зачеркнуто. Число k будет
зачеркнуто, если оно кратно какому-то простому числу p <= sqrt(k). Таких простых чисел не более, чем sqrt(k)/ln(sqrt(k))
по теореме о распределении простых чисел. Следовательно, общее количество зачеркиваний не превосходит суммы от k = 2 до
n членов sqrt(k)/ln(sqrt(k)), которая асимптотически равна (2*n^(3/2))/(3*ln(n)) по интегральному признаку. Таким
образом, сложность алгоритма равна O(n^(3/2)/ln(n)).

```c++
#include <iostream>

// Функция, которая находит все простые числа от 2 до n с помощью решета Эратосфена
void sieve_of_eratosthenes(int n) {
  // Создаем указатель на логический тип и выделяем память под массив размером n + 1
  bool* is_prime = new bool[n + 1];
  // Инициализируем все элементы массива как true
  for (int i = 0; i <= n; i++) {
    is_prime[i] = true;
  }
  // Перебираем все числа от 2 до корня из n
  for (int i = 2; i * i <= n; i++) {
    // Если i простое, то вычеркиваем все его кратные
    if (is_prime[i]) {
      for (int j = i * i; j <= n; j += i) {
        is_prime[j] = false;
      }
    }
  }
  // Выводим все простые числа
  std::cout << "Простые числа от 2 до " << n << ": ";
  for (int i = 2; i <= n; i++) {
    if (is_prime[i]) {
      std::cout << i << " ";
    }
  }
  std::cout << endl;
  // Освобождаем память, занятую массивом
  delete[] is_prime;
}
```

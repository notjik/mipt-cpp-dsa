Алгоритм бинарного поиска по ответу - это метод решения задач, в которых требуется найти максимальное или минимальное значение некоторой функции, удовлетворяющее некоторому условию. Примером такой задачи может быть поиск корня уравнения или оптимального расстояния между объектами. Алгоритм работает следующим образом:

- Задаётся начальный интервал возможных значений ответа, например, от минимального до максимального значения функции.
- На каждом шаге выбирается середина интервала и проверяется, выполняется ли условие для этого значения. Если да, то интервал сужается с одной из сторон, иначе - с другой.
- Процесс повторяется, пока интервал не станет достаточно маленьким или не будет найдено точное решение.

Алгоритм бинарного поиска по ответу эффективен, так как на каждом шаге он уменьшает интервал в два раза, то есть имеет логарифмическую сложность. Однако, для его применения необходимо, чтобы функция была монотонной (то есть не возрастала или не убывала) и условие было проверяемо за константное время.

Решение задачи о двух принтерах, печатающих n листов за минимальное время
```c++
// Функция, которая проверяет, можно ли напечатать n листов за t минут
bool check(int t, int n, int x, int y) {
  // Количество листов, которые напечатает первый принтер за t минут
  int a = t / x;
  // Количество листов, которые напечатает второй принтер за t минут
  int b = t / y;
  // Возвращаем true, если сумма листов не меньше n, иначе false
  return a + b >= n;
}

// Функция, которая находит минимальное время, за которое можно напечатать n листов
int solve(int n, int x, int y) {
  // Начальный интервал возможных значений времени
  int l = 0; // Минимальное время - 0 минут
  int r = n * max(x, y); // Максимальное время - n * max(x, y) минут
  // Пока интервал не станет достаточно маленьким
  while (r - l > 1) {
    // Находим середину интервала
    int m = (l + r) / 2;
    // Проверяем, можно ли напечатать n листов за m минут
    if (check(m, n, x, y)) {
      // Если можно, то сужаем интервал с правой стороны
      r = m;
    } else {
      // Если нельзя, то сужаем интервал с левой стороны
      l = m;
    }
  }
  // Возвращаем правую границу интервала, как минимальное время
  return r;
}

```
Задача о рюкзаке является классической задачей комбинаторной оптимизации и является NP-полной. Она заключается в выборе
подмножества предметов с максимальной общей стоимостью, при условии соблюдения ограничения на суммарный вес.

Математически задача формулируется следующим образом: имеется n грузов. Для каждого i-го груза определены его масса
w_i и ценность v_i. Ограничение суммарного веса предметов в рюкзаке задаётся грузоподъёмностью W. Необходимо
максимизировать сумму от i=1 до n v_i * x_i с ограничениями в виде суммы от i=1 до n w_i * x_i <= W и x_i in {0,1}.

Одним из способов решения задачи о рюкзаке является метод динамического программирования. Сложность этого метода
составляет O(nW), где n - количество предметов, а W - вместимость рюкзака. Это означает, что время выполнения
алгоритма прямо пропорционально произведению количества предметов и вместимости рюкзака.

Однако стоит отметить, что данная асимптотика является псевдополиномиальной, а не полиномиальной, поскольку W - это не
размер входных данных, а значение входных данных. В случае, когда W может быть экспоненциально большим, время выполнения
алгоритма также может быть экспоненциально большим. Это одна из причин, по которой задача о рюкзаке считается
NP-полной.

```c++
#include <algorithm>
#include <iostream>

int main() {
  int w, n;
  std::cin >> w >> n; // Считывание вместимости рюкзака и количества предметов

  // Создание двумерного массива для хранения промежуточных результатов
  int** dp = new int*[n + 1];
  for (int i = 0; i < n + 1; i++) {
    dp[i] = new int[w + 1];
  }

  // Инициализация массива нулями
  for (int i = 0; i < n + 1; i++) {
    dp[i][0] = 0;
  }
  for (int i = 0; i < w + 1; i++) {
    dp[0][i] = 0;
  }

  // Обработка каждого предмета
  for (int i = 1; i < n + 1; i++) {
    int cur_c, cur_w;
    std::cin >> cur_c >> cur_w; // Считывание стоимости и веса текущего предмета

    // Обработка каждого возможного веса рюкзака
    for (int j = 1; j < w + 1; j++) {
      if (cur_w <= j) {
        // Если текущий предмет можно добавить в рюкзак, выбираем максимальное значение
        dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - cur_w] + cur_c);
      } else {
        // Если текущий предмет не помещается в рюкзак, переносим значение из предыдущего шага
        dp[i][j] = dp[i - 1][j];
      }
    }
  }

  // Поиск максимальной стоимости, которую можно получить, не превышая вместимость рюкзака
  {
    int i = w;
    while (i >= 0 && dp[n][i] == dp[n][i - 1]) {
      i--;
    }
    std::cout << dp[n][i] << ' ' << i; // Вывод максимальной стоимости и соответствующей вместимости рюкзака
  }

  // Освобождение памяти, выделенной под массив dp
  for (int i = 0; i < n + 1; i++) {
    delete[] dp[i];
  }
  delete[] dp;

  return 0;
}

```

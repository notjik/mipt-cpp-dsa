Свойства сортировок зависят от того, как они работают с данными. Одно из важных свойств - это **устойчивость**, то есть
сохранение относительного порядка элементов с одинаковыми ключами. Устойчивые сортировки обычно требуют больше памяти,
чем неустойчивые, но могут быть полезны в некоторых случаях.

Другое важное свойство - это **потребляемые ресурсы**, то есть время и память, необходимые для выполнения сортировки.
Обычно время работы сортировки оценивается с помощью **асимптотического анализа**, который показывает, как меняется
время в зависимости от размера входных данных. Для этого используются разные понятия, такие как **лучший**, **средний**
и **худший** случаи, а также разные **классы сложности**, такие как **линейная**, **логарифмическая**, *
*линейно-логарифмическая** и **квадратичная**.

Тривиальная сортировка - это сортировка, которая не делает никаких действий, если массив уже отсортирован, или же просто
копирует массив в новый, если он не отсортирован. Это самая простая и быстрая сортировка, но она работает только для
отсортированных или пустых массивов. Её асимптотика - O (n) в лучшем и среднем случаях и O (n^2) в худшем случае. Она
устойчива и не требует дополнительной памяти.

Квадратичные сортировки - это сортировки, которые имеют асимптотику O (n^2) в худшем случае. Они работают за
квадратичное время, потому что они сравнивают или перемещают каждый элемент массива с каждым другим элементом. К ним
относятся **Selection sort**, **Insertion sort** и **Bubble sort**.

Поиск максимума и минимума - это задача, которая состоит в нахождении наибольшего и наименьшего элементов массива. Она
может быть решена с помощью линейного поиска, который просто перебирает все элементы массива и сравнивает их с текущими
максимумом и минимумом. Её асимптотика - O (n) во всех случаях. Она не требует дополнительной памяти.

Доказательство асимптотик и корректности - это процесс, который показывает, что алгоритм сортировки работает правильно и
имеет ожидаемую сложность. Для этого обычно используются **инварианты цикла**, **рекуррентные соотношения** и **метод
математической индукции**. Например, для доказательства корректности Selection sort можно использовать инвариант цикла,
который гласит, что после i-той итерации внешнего цикла первые i элементов массива отсортированы и не больше остальных
элементов. Для доказательства асимптотики Selection sort можно использовать рекуррентное соотношение, которое гласит,
что время работы T (n) удовлетворяет T (n) = T (n-1) + O (n), откуда следует, что T (n) = O (n^2).

---

BubbleSort - это сортировка, которая на каждом шаге сравнивает пары соседних элементов массива и меняет их местами, если
они не упорядочены. Её асимптотика - O (n) в лучшем случае, O (n^2) в среднем и худшем случаях. Она устойчива и не
требует дополнительной памяти.

Для доказательства корректности BubbleSort можно использовать инвариант цикла, который гласит, что после i-той итерации
внешнего цикла все элементы с индексами больше или равными n-i отсортированы и не меньше остальных элементов. Для
доказательства этого инварианта можно использовать метод математической индукции по i. База: при i = 0, инвариант верен,
так как все элементы с индексами больше или равными n отсортированы и не меньше остальных элементов (пустое
утверждение). Шаг: пусть инвариант верен для i = k, докажем его для i = k+1. После (k+1)-той итерации внешнего цикла, мы
знаем, что все элементы с индексами больше или равными n-k отсортированы и не меньше остальных элементов по
предположению индукции. Кроме того, мы знаем, что внутренний цикл сравнивает и меняет местами все пары элементов с
индексами от 0 до n-k-1. Это означает, что после внутреннего цикла, элемент с индексом n-k-1 будет наибольшим из всех
элементов с индексами от 0 до n-k-1. Таким образом, после (k+1)-той итерации внешнего цикла, все элементы с индексами
больше или равными n-(k+1) отсортированы и не меньше остальных элементов, что и требовалось доказать.

Для доказательства асимптотики BubbleSort можно использовать рекуррентное соотношение, которое гласит, что время работы
T (n) удовлетворяет T (n) = T (n-1) + O (n), откуда следует, что T (n) = O (n^2). Для доказательства этого соотношения
можно заметить, что на каждой итерации внешнего цикла, внутренний цикл делает O (n) сравнений и обменов, а количество
итераций внешнего цикла равно n. Таким образом, общее время работы равно сумме времени работы внутреннего цикла на
каждой итерации внешнего цикла, то есть T (n) = O (n) + O (n-1) + ... + O (1) = O (n^2).

```c++
void BubbleSort(int *arr, const int size) {
  for (int i = 0; i < size; i++) {
    bool is_permutations = false;
    for (int j = 0; j < size - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        std::swap(arr[j], arr[j + 1]);
        is_permutations = true;
      }
    }
    if (!is_permutations) {
      break;
    }
  }
}
```

---

SelectionSort - это сортировка, которая на каждом шаге выбирает наименьший элемент из неотсортированной части массива и
ставит его в конец отсортированной части. Её асимптотика - O (n^2) во всех случаях. Она не обязательно должна быть
устойчива и не требует дополнительной памяти.

Для доказательства корректности SelectionSort можно использовать инвариант цикла, который гласит, что после i-той
итерации внешнего цикла первые i элементов массива отсортированы и не больше остальных элементов. Для доказательства
этого инварианта можно использовать метод математической индукции по i. База: при i = 0, инвариант верен, так как все
элементы с индексами больше или равными n отсортированы и не больше остальных элементов (пустое утверждение). Шаг: пусть
инвариант верен для i = k, докажем его для i = k+1. После (k+1)-той итерации внешнего цикла, мы знаем, что все элементы
с индексами больше или равными n-k отсортированы и не больше остальных элементов по предположению индукции. Кроме того,
мы знаем, что внутренний цикл находит наименьший элемент из неотсортированной части массива и меняет его местами с
элементом с индексом k. Это означает, что после (k+1)-той итерации внешнего цикла, первые (k+1) элементов массива
отсортированы и не больше остальных элементов, что и требовалось доказать.

Для доказательства асимптотики SelectionSort можно использовать рекуррентное соотношение, которое гласит, что время
работы T (n) удовлетворяет T (n) = T (n-1) + O (n), откуда следует, что T (n) = O (n^2). Для доказательства этого
соотношения можно заметить, что на каждой итерации внешнего цикла, внутренний цикл делает O (n) сравнений, а количество
итераций внешнего цикла равно n. Таким образом, общее время работы равно сумме времени работы внутреннего цикла на
каждой итерации внешнего цикла, то есть T (n) = O (n) + O (n-1) + ... + O (1) = O (n^2).

```c++
void SelectionSort(int *arr, const int size) {
  for (int i = 0; i < size - 1; i++) {
    int min_index = i;
    for (int j = i + 1; j < size; j++) {
      if (arr[j] < arr[min_index]) {
        min_index = j;
      }
    }
    std::swap(arr[i], arr[min_index]);
  }
}
```

---

InsertionSort - это сортировка, которая на каждом шаге берет следующий элемент из неотсортированной части массива и
вставляет его на правильное место в отсортированной части. Её асимптотика - O (n) в лучшем случае, O (n^2) в среднем и
худшем случаях. Она устойчива и не требует дополнительной памяти¹.

Для доказательства корректности InsertionSort можно использовать инвариант цикла, который гласит, что после i-той
итерации внешнего цикла первые i элементов массива отсортированы. Для доказательства этого инварианта можно использовать
метод математической индукции по i. База: при i = 0, инвариант верен, так как все элементы массива неотсортированы (
пустое утверждение). Шаг: пусть инвариант верен для i = k, докажем его для i = k+1. После (k+1)-той итерации внешнего
цикла, мы знаем, что первые k элементов массива отсортированы по предположению индукции. Кроме того, мы знаем, что
внутренний цикл вставляет элемент с индексом k+1 на правильное место в отсортированной части, сдвигая все большие
элементы на одну позицию вправо. Это означает, что после (k+1)-той итерации внешнего цикла, первые (k+1) элементов
массива отсортированы, что и требовалось доказать.

Для доказательства асимптотики InsertionSort можно использовать рекуррентное соотношение, которое гласит, что время
работы T (n) удовлетворяет T (n) = T (n-1) + O (n), откуда следует, что T (n) = O (n^2). Для доказательства этого
соотношения можно заметить, что на каждой итерации внешнего цикла, внутренний цикл делает O (n) сравнений и сдвигов, а
количество итераций внешнего цикла равно n. Таким образом, общее время работы равно сумме времени работы внутреннего
цикла на каждой итерации внешнего цикла, то есть T (n) = O (n) + O (n-1) + ... + O (1) = O (n^2).

```c++
void InsertionSort(int *arr, const int size) {
  for (int i = 1; i < size; i++) {
    int x = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > x) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = x;
  }
}
```
Алгоритм нахождения наибольшей возрастающей подпоследовательности (LIS) за время O(NlogN) работает
следующим образом:

1. Инициализируем массив `tail` размером `N`, где `N` - это количество элементов в исходном массиве. Этот массив будет
   хранить конечные элементы всех возможных возрастающих подпоследовательностей, которые мы обнаружили до сих пор.
   Заполняем его бесконечно большими значениями.

2. Проходим по исходному массиву слева направо. Для каждого элемента `arr[i]` выполняем следующие действия:
    - Если `arr[i]` меньше всех конечных элементов текущих подпоследовательностей, то начинаем новую
      подпоследовательность с `arr[i]`.
    - Если `arr[i]` больше всех конечных элементов текущих подпоследовательностей, то продлеваем самую длинную
      подпоследовательность `arr[i]`.
    - Если `arr[i]` находится между этими двумя случаями, то заменяем конечный элемент некоторой подпоследовательности
      на `arr[i]`.

3. Длина LIS будет равна индексу первого бесконечного значения в массиве `tail`.

**Доказательство асимптотического времени и памяти:**

- **Время**: На каждом шаге мы либо обновляем значение в массиве `tail`, либо добавляем новое значение в конец. Оба этих
  действия можно выполнить за O(logN) с помощью двоичного поиска. Так как мы делаем это для каждого
  из `N` элементов, общее время работы составляет O(NlogN).

- **Память**: Мы используем один дополнительный массив `tail` размером `N` для хранения конечных элементов
  подпоследовательностей. Таким образом, требуется O(N) дополнительной памяти.

Этот алгоритм является эффективным решением для задачи нахождения наибольшей возрастающей подпоследовательности. Он
оптимизирует как время, так и использование памяти.

```c++
#include <climits>
#include <iostream>

int main() {
  int n;
  std::cin >> n; // Вводим количество элементов в массиве
  auto arr = new int[n]; // Создаем массив для хранения элементов
  for (int i = 0; i < n; ++i) {
    std::cin >> arr[i]; // Вводим элементы массива
  }
  auto dp = new int[n + 1]; // Создаем массив dp для хранения конечных элементов подпоследовательностей
  dp[0] = INT_MIN; // Инициализируем первый элемент минимальным значением
  for (int i = 1; i < n + 1; ++i) {
    dp[i] = INT_MAX; // Заполняем остальные элементы максимальными значениями
  }
  for (int i = 0; i < n; i++) { // Проходим по исходному массиву
    int left = -1;
    int right = n;
    while (left < right - 1) { // Выполняем двоичный поиск для нахождения подходящего места для arr[i] в массиве dp
      int mid = (left + right) / 2;
      if (dp[mid] < arr[i]) {
        left = mid;
      } else {
        right = mid;
      }
    }
    if (dp[right - 1] < arr[i] && arr[i] < dp[right]) { // Если arr[i] больше dp[right - 1] и меньше dp[right], то заменяем dp[right] на arr[i]
      dp[right] = arr[i];
    }
  }
  int counter = 0;
  for (int i = 1; i < n + 1; i++) { // Подсчитываем количество элементов в наибольшей возрастающей подпоследовательности
    if (dp[i] != INT_MAX && dp[i] != INT_MIN) {
      counter++;
    }
  }
  std::cout << counter; // Выводим результат
  delete[] dp; // Освобождаем память
  delete[] arr; // Освобождаем память
  return 0;
}

```
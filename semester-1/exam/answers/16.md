**АТД Стек на односвязном списке**

Стек можно представить как список с элементами и указателем на вершину стека, указывающим на последний элемент,
добавленный в стек². Каждый раз, когда в стек добавляется новый элемент, указатель на вершину смещается на следующий
элемент. Когда элемент удаляется из вершины стека, указатель смещается на предыдущий элемент². Если указатель находится
в конце стека, то стек пуст².

Операции со стеком имеют следующую асимптотическую сложность:

- Добавление элемента в вершину стека (push) — O(1). Это связано с тем, что нам просто нужно добавить элемент в конец
  списка и обновить указатель на вершину стека.
- Удаление элемента из вершины стека (pop) — O(1). Мы просто удаляем элемент из конца списка и обновляем указатель на
  вершину стека.
- Возврат верхнего элемента без его удаления (peek) — O(1). Мы просто возвращаем элемент, на который указывает указатель
  на вершину стека.
- Проверка стека на пустоту (isEmpty) — O(1). Мы просто проверяем, указывает ли указатель на вершину стека на конец
  списка.

```c++
#include <iostream>

struct Node {
  int _val;
  Node* _next = nullptr;
};

struct Stack {
  Node* _head = nullptr;
  size_t _size = 0;

  size_t Size() {
    return _size;
  }
  
  bool IsEmpty(){
    return _size == 0;
  }

  void Push(int val) {
    auto* node = new Node{val, _head};
    _head = node;
    _size++;
  }

  void Pop() {
    if (!Size()) {
      return;
    }
    Node* save = _head->_next;
    delete _head;
    _head = save;
    _size--;
  }

  void Back() {
    if (!Size()) {
      return;
    }
    std::cout << _head->_val << '\n';
  }

  void Clear() {
    while (Size()) {
      Pop();
    }
  }
};
```

---

**АТД Очередь на стеке**

Очередь можно реализовать с использованием двух стеков. Один стек используется для вставки элементов (enqueue), а другой
стек используется для удаления элементов (dequeue).

Операции с очередью имеют следующую асимптотическую сложность:

- Вставка элемента в конец очереди (enqueue) — O(1). Мы просто добавляем элемент в конец одного из стеков.
- Удаление элемента из начала очереди (dequeue) — амортизированное O(1) с O(n), так как все элементы должны быть
  перенесены из одного стека в другой. Это связано с тем, что элементы в стеке хранятся в обратном порядке по сравнению
  с их порядком в очереди и мы можем переносить элементы во второй стек для удаления до опустошения второго стека.
- Возврат первого элемента без его удаления (peek) — амортизированное O(1) с O(n), по той же причине, что и операция
  dequeue.
- Проверка очереди на пустоту (isEmpty) — O(1). Мы просто проверяем, пусты ли оба стека.

Память, используемая для стека и очереди, пропорциональна количеству элементов в стеке или очереди, то есть O(n), где
n - количество элементов. Это объясняется тем, что каждый элемент в стеке или очереди занимает некоторое фиксированное
количество памяти.

```c++
#include <iostream>

struct Node {
  int _val;
  Node* _next = nullptr;
};

struct Stack {
  Node* _head = nullptr;
  size_t _size = 0;

  size_t Size() {
    return _size;
  }
  
  bool IsEmpty(){
    return _size == 0;
  }

  void Push(int val) {
    auto* node = new Node{val, _head};
    _head = node;
    _size++;
  }

  void Pop() {
    if (IsEmpty()) {
      return;
    }
    Node* save = _head->_next;
    delete _head;
    _head = save;
    _size--;
  }

  void Back() {
    if (IsEmpty()) {
      return;
    }
    std::cout << _head->_val << '\n';
  }

  void Clear() {
    while (Size()) {
      Pop();
    }
  }
};


struct QueueInStack {
  Stack in;
  Stack out;
  
  ~QueueInStack(){
    in.Clear();
    out.Clear();
  }
  
  bool IsEmpty() {
    return in.IsEmpty() || out.IsEmpty();
  }
  
  void FixOut(){
    if (out.IsEmpty()) {
      for (int i = 0; i < in.Size(); i++) {
        out.Push(in.Pop());
      }
    }
  }
  
  void Enqueue(int val) {
    in.Push(val);
  }
  
  void Dequeue() {
    FixOut();
    if (!out.IsEmpty()) {
      out.Pop()
    }
  }
  
  void Peek() {
    FixOut();
    if (!out.IsEmpty()) {
      out.Back()
    }
  }
};
```

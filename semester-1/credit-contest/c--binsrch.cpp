/*
# Задача C(2). BINSRCH [АиСД 2023]

**Ограничение времени**: 2 секунды
**Ограничение памяти**: 256.0 Мб
**Ввод**: стандартный ввод или input.txt
**Вывод**: стандартный вывод или output.txt

## Маша и Медведь решают головоломку. Нашла, нашла, а я тебя нашла! Не умеешь ты, Мишка, прятаться.

Однажды Мишка смог найти огромную бочку меда. И как бы он ни любил Машу, делиться с ней особого желания не было.

Тогда он решил закопать бочку под одним из больших камней, что лежали вдоль тропинки от Мишкиного дома до Машиного.

На каждом камне он написал какое-то число: важно, что все числа упорядочены по возрастанию от Машиного дома, до Мишкиного!

Потом Медведь написал на запястье число - то, что написано на том камне, под которым спрятана бочка.

Маша, идя по дорожке, заметила, что кое-где перекопана тропинка и догадалась, что Медведь от нее что-то прячет. Помогите Маше найти номер того камня, под которым закопан клад.

Известно, что Медведи не знают очень-очень больших чисел, поэтому все числа на камнях не превышают 10^9.

Перед зачетом Иван Дмитриевич побегал по тропинке и посчитал количество камешков - их оказалось 10^5, а значит число покрашенных камней не может быть больше этого значения.

Потом вводятся запросы от Маши - есть ли такой камень, значение которого она загадала в последовательности и где он находится.

## Формат ввода

На первой строке вводится число N - длина массива (1 ≤ N ≤ 10^5) и N значений элементов этого массива, каждое из которых не превышает 10^9.

На второй строчке вводится число K - количество запросов (1 ≤ K ≤ 10^5) и K значений запросов к массиву, каждый из которых не превышает 10^9.

## Формат вывода

Для каждого запроса x, необходимо вывести индекс 1 ≤ i ≤ N, для которого ARRAY[i] = x, или -1, если такого i не существует.

## Пример

### Ввод
```
5 1 5 8 12 13
5 8 1 23 1 11
```
### Вывод
```
3 1 -1 1 -1
```
 */
#include <iostream>

int BinSearch(int* arr, int n, int key) {
  int left = 0;
  int right = n;
  int mid = (left + right) / 2;
  while (left < right - 1) {
    if (arr[mid] > key) {
      right = mid;
    } else {
      left = mid;
    }
    mid = (left + right) / 2;
  }
  return (arr[left] == key ? left : -2);
}

int main() {
  std::cin.tie();
  std::cout.tie();
  int n;
  std::cin >> n;
  auto arr = new int[n];
  for (int i = 0; i < n; i++) {
    std::cin >> arr[i];
  }
  int k;
  std::cin >> k;
  auto req = new int[k];
  for (int i = 0; i < k; i++) {
    std::cin >> req[i];
  }
  for (int i = 0; i < k; i++) {
    std::cout << BinSearch(arr, n, req[i]) + 1 << ' ';
  }
  return 0;
}

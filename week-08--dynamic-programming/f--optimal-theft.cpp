/*
# F. Оптимальная кража

**Ограничение времени:** 1 секунда
**Ограничение памяти:** 64Mb
**Ввод:** стандартный ввод или input.txt
**Вывод:** стандартный вывод или output.txt

## Задача

Сегодня гипотетически мы с вами совершим ограбление. В чем прелесть быть вором - можно брать очень дорогие вещи, затратив на это минимальное количество усилий. В чем минус? Можно быть пойманным. Но есть идеальное равновесие - когда вы "позаимствовали" вещей на максимальную стоимость, тем не менее, их общий вес должен не превышать определенный размер, чтобы можно было спокойно удирать от копов.

То есть задача состоит в следующем: вор заходит в квартиру, и видит набор вещей. Он знает их стоимость и вес. Необходимо набрать самые дорогие вещи, не превысив максимальный вес, который может унести вор.

## Формат ввода

В первой строчке вводится W - максимальный суммарный вес украденных предметов. Во второй строке натуральное число N - количество предметов, которое видит вор. На каждой из последующих N строк записаны пары натуральных чисел - стоимость предмета и его вес соответственно.

## Формат вывода

Через пробел два числа - наибольшая стоимость украденных предметов и их суммарный вес.

## Примеры

**Пример 1**

**Ввод**

```
20
6
457 12
759 1
901 4
645 12
516 8
182 17
```

**Вывод**

```
2305 17
```

**Пример 2**

**Ввод**

```
20
10
837 9
868 6
431 8
350 1
324 13
179 6
301 1
52 4
963 14
28 15
```

**Вывод**

```
2356 17
```
 */
#include <algorithm>
#include <iostream>

int main() {
  int w, n;
  std::cin >> w >> n;
  int** dp = new int*[n + 1];
  for (int i = 0; i < n + 1; i++) {
    dp[i] = new int[w + 1];
  }
  for (int i = 0; i < n + 1; i++) {
    dp[i][0] = 0;
  }
  for (int i = 0; i < w + 1; i++) {
    dp[0][i] = 0;
  }
  for (int i = 1; i < n + 1; i++) {
    int cur_c, cur_w;
    std::cin >> cur_c >> cur_w;
    for (int j = 1; j < w + 1; j++) {
      if (cur_w <= j) {
        dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - cur_w] + cur_c);

      } else {
        dp[i][j] = dp[i - 1][j];
      }
    }
  }
  {
    int i = w;
    while (i >= 0 && dp[n][i] == dp[n][i - 1]) {
      i--;
    }
    std::cout << dp[n][i] << ' ' << i;
  }
  for (int i = 0; i < n + 1; i++) {
    delete[] dp[i];
  }
  delete[] dp;
  return 0;
}
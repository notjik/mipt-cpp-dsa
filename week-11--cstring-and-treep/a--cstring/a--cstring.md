# Задача A. CString

**Ограничение времени**: 0.1 секунд  
**Ограничение памяти**: 8.0 Мб  
**Ввод**: стандартный ввод или input.txt  
**Вывод**: стандартный вывод или output.txt

*C-style строкой называется последовательность байт (`char`), ограниченная нулевым символом (`'\0'`). Работа с C-style строками во многом похожа на работу с массивами, при этом специфичные для строк операции (вычисление длины, конкатенация, сравнение и т.п.) вынесены в отдельную библиотеку функций. В этом задании вам предстоит познакомиться с ней подробнее, реализовав собственный аналог.*

## Условие задачи

Реализуйте модуль `cstring`, состоящий из следующих функций:

1. `size_t Strlen(const char* str);` - Вычисляет длину строки str (без учета нулевого символа).
2. `int Strcmp(const char* first, const char* second);` - Лексикографически сравнивает две строки. Если first < second, то возвращает произвольное отрицательное число, если first > second, то - положительное. В случае равенства возвращает 0.
3. `int Strncmp(const char* first, const char* second, size_t count);` - То же, что и предыдущая функция, но сравнивает первые count символов строк (либо пока не встретит нулевой символ).
4. `char* Strcpy(char* dest, const char* src);` - Принимает строку src и копирует ее содержимое (вместе с нуль-терминатором) в dest. Гарантируется, что dest указывает на область памяти, достаточную для хранения src. Возвращает dest. **Замечание: формально, std::strcpy дополнительно требует, чтобы последовательности dest и src не перекрывались (то есть длина строки src должна быть больше расстояния между указателями), так как порядок копирования символов не определен. В этом задании допускается более слабое предположение: dest не указывает внутрь строки src.**
5. `char* Strncpy(char* dest, const char* src, size_t count);` - То же, что и предыдущая функция, но копирует ровно count символов из src. Если count больше размера src, то оставшиеся символы заполняются нуль-символами. Возвращает dest.
6. `char* Strcat(char* dest, const char* src);` - Приписывает строку src в конец строки dest (конкатенация строк). Гарантируется, что dest указывает на область памяти, достаточную для хранения итоговой строки. Возвращает dest.
7. `char* Strncat(char* dest, const char* src, size_t count);` - То же, что и предыдущая функция, но добавляет только первые count символов из src + нулевой символ. Если count больше чем длина src, то работает так же как и Strcat(dest, src). Возвращает dest.
8. `const char* Strchr(const char* str, char symbol);` - Возвращает указатель на первое появление символа symbol в строке str (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
9. `const char* Strrchr(const char* str, char symbol);` - Возвращает указатель на последнее появление символа symbol в строке str (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
10. `size_t Strspn(const char* dest, const char* src);` - Возвращает количество первых символов dest, которые встречаются в строке src (без учета нулевого символа).
11. `size_t Strcspn(const char* dest, const char* src);` - Возвращает количество первых символов dest, которые не встречаются в строке src (без учета нулевого символа).
12. `const char* Strpbrk(const char* dest, const char* breakset);` - Возвращает указатель на первый элемент dest, который лежит в breakset, либо нулевой указатель, если такого элемента нет.
13. `const char* Strstr(const char* str, const char* pattern);` - Осуществляет поиск подстроки pattern в строке str. Возвращает указатель на начало первого вхождения, либо нулевой указатель, если вхождения найдено не было.

При необходимости подробнее про работу функций можете прочитать на странице [https://cplusplus.com/reference/cstring/](https://cplusplus.com/reference/cstring/). **Использовать функции memcpy, memcmp и подобные запрещено.**

В качестве решения от вас ожидается модуль, состоящий из 2х файлов: `cstring.h` и `cstring.cpp`. Файлы присылайте в виде **ZIP**-архива.

Присланный модуль будет собран вместе с файлом с тестами на сервере, `main` присылать **не нужно**. Интерфейс функций должен в точности совпадать с тем, что описан в условии (тесты ожидают именно его), в противном случае вы получите ошибку компиляции.

При ошибке в реализации вы получите вердикт `CE`. В нем будет указана функция, которая требует исправлений.